"""
Definition of the abstract base class for Shells.
"""
from abc import ABCMeta, abstractmethod
import os

from . import get_class, get_kind, load


class Shell(metaclass=ABCMeta):
    """
    The base class of a system shell.
    """

    def __init__(self, pid, configuration_dir, control_filename):
        self._shell_pid = pid
        self._configuration_dir = configuration_dir
        self._control_filename = control_filename

    @property
    def shell_type(self):
        """
        :return: The shell's kind (name) in a textual format.
        """
        return get_kind(type(self))

    @property
    def shell_pid(self):
        """
        :return: The process ID of the shell.
        """
        return self._shell_pid

    @property
    def configuration_directory(self):
        """
        :return: The directory where data for the :type:`Shell` instance
        is persisted on a storage medium.

        This is, in all cases, a temporary directory, which is only used to
        interface between subsequent Envprobe calls and the shell hook.
        """
        return self._configuration_dir

    @property
    def control_file(self):
        """
        :return: The location of the shell hook's control file.
        """
        return os.path.join(self.configuration_directory,
                            self._control_filename)

    @property
    def state_file(self):
        """
        :return: The path of a file persisted in storage which is used to
        consider the "saved" state of the shell.
        """
        # TODO: Pickle is a bit outdated and sometimes insecure, we need to use
        #       a better serialisation method.
        return os.path.join(self.configuration_directory, 'state.pickle')

    @property
    @abstractmethod
    def is_envprobe_capable(self):
        """
        :return: Whether the current shell is capable of loading and
        meaningfully running Envprobe.
        """
        pass

    @abstractmethod
    def get_shell_hook(self, envprobe_callback_location):
        """
        :return: A generated code that is to be evaluated inside the shell
        directly. This code is used to set up the shell hook that drives the
        changes generated by Envprobe.
        """
        pass

    @property
    @abstractmethod
    def manages_environment_variables(self):
        """
        :return: Whether the current :type:`Shell` instance is capable of
        managing environment variables of the system shell session.
        """
        pass

    def _set_environment_variable(self, env_var):
        pass

    def set_environment_variable(self, env_var):
        """
        Generate executed code that will set the value of :param:`env_var` in
        the system shell session to what is present in memory.

        This method writes :func:`control_file`.
        """
        if not self.manages_environment_variables:
            # TODO: Turn this into a meaningful exception type.
            raise TypeError("This shell instance cannot manage environment "
                            "variables.")
        return self._set_environment_variable(env_var)

    def _unset_environment_variable(self, env_var):
        pass

    def unset_environment_variable(self, env_var):
        """
        Generate executed code that will undefine the given :param:`env_var`
        in the system shell session.

        This method writes :func:`control_file`.
        """
        if not self.manages_environment_variables:
            # TODO: Turn this into a meaningful exception type.
            raise TypeError("This shell instance cannot manage environment "
                            "variables.")
        return self._unset_environment_variable(env_var)


class FakeShell(Shell):
    """
    Implements a fake :type:`Shell`, which provides all the methods necessary
    to be a proper subclass but with guarding against useful facilities.

    This class is *NOT* available through using :func:`shell.load()`.
    """
    def __init__(self):
        super().__init__(-1, os.path.curdir, "null.txt")

    @property
    def shell_type(self):
        return ""

    @property
    def control_file(self):
        return os.path.devnull

    @property
    def state_file(self):
        return os.path.devnull

    @property
    def is_envprobe_capable(self):
        return False

    def get_shell_hook(self, envprobe_callback_location):
        return ""

    @property
    def manages_environment_variables(self):
        return False


def get_current_shell(environment_dict):
    """
    Creates a Shell instance based on the current environment mapping,
    if possible.

    Returns False if the current shell type is unknown or None if the user
    does not have envprobe enabled.
    """
    shell_type = environment_dict.get("ENVPROBE_SHELL_TYPE", None)
    if not shell_type:
        raise KeyError("Current shell's type is not configured.")

    clazz = None
    try:
        clazz = get_class(shell_type)
    except KeyError:
        clazz = load(shell_type)
        if not clazz:
            raise NotImplementedError("Shell '%s' failed to load.")

    shell = clazz(environment_dict.get("ENVPROBE_SHELL_PID"),
                  environment_dict.get("ENVPROBE_CONFIG"))

    return shell
